package main

import (
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

type Config struct {
	Version       string `json:"version"`
	VersionServer string `json:"version_server"`
	Compiler      string `json:"compiler"`
	Output        string `json:"output"`
	Publisher     string `json:"publisher"`
	Url           string `json:"url"`
	Apps          []App  `json:"apps"`
}

type App struct {
	Id          string       `json:"app_id"`
	Name        string       `json:"app_name"`
	ExeName     string       `json:"app_exe"`
	DebugPath   string       `json:"debug_path"`
	SetupTarget string       `json:"setup_target_path"`
	VcRedist    string       `json:"vcredist"`
	Externs     []ExternPath `json:"extern_path"`
	WorkPath    string
}

type ExternPath struct {
	Source   string `json:"source"`
	Target   string `json:"target"`
	Override bool   `json:"override"`
}

var currentPath string
var innoProfileTemplate = `
; Script generated by the Inno Setup Script Wizard.
; SEE THE DOCUMENTATION FOR DETAILS ON CREATING INNO SETUP SCRIPT FILES!

$DEFINES$

[Setup]
; NOTE: The value of AppId uniquely identifies this application.
; Do not use the same AppId value in installers for other applications.
; (To generate a new GUID, click Tools | Generate GUID inside the IDE.)
AppId=$APPID$
AppName={#AppName}
AppVersion={#AppVersion}
;AppVerName={#AppName} {#AppVersion}
AppPublisher={#AppPublisher}
AppPublisherURL={#AppURL}
AppSupportURL={#AppURL}
AppUpdatesURL={#AppURL}
DefaultDirName=$SETUP_TARGET$
DefaultGroupName=Atom
OutputBaseFilename={#AppName}_{#AppVersion}
Compression=lzma
SolidCompression=yes
PrivilegesRequired=admin

[Languages]
Name: "english"; MessagesFile: "compiler:Default.isl"

[Tasks]
Name: "desktopicon"; Description: "{cm:CreateDesktopIcon}"; GroupDescription: "{cm:AdditionalIcons}"

[Files]
; Program Files
$PROGRAM_FILES$

; Extern Files
$EXTERN_FILES$

; NOTE: Don't use "Flags: ignoreversion" on any shared system files

; can not replace \ to /
[Icons]
Name: "{group}\{#AppName}"; Filename: "{app}\{#AppExeName}"
Name: "{commondesktop}\{#AppName}"; Filename: "{app}\{#AppExeName}"; Tasks: desktopicon

[Run]
Filename: "{app}\{#AppExeName}"; Description: "{cm:LaunchProgram,{#StringChange(AppName, '&', '&&')}}"; Flags: nowait postinstall skipifsilent
$RUN$

; copy a vcredist_x64.exe to install path first
[Code]
$CODE$
`

var config = Config{}

func loadConfig(cfg string) {
	text, err := ioutil.ReadFile(cfg)
	if err != nil {
		log.Fatal(err)
	}
	if err := json.Unmarshal(text, &config); err != nil {
		log.Fatal(err)
	}

	config.VersionServer = strings.Trim(config.VersionServer, " ")
	if !strings.HasSuffix(config.VersionServer, "/") {
		config.VersionServer += "/"
	}

	for idx, app := range config.Apps {
		if !filepath.IsAbs(app.DebugPath) {
			config.Apps[idx].DebugPath, err = filepath.Abs(currentPath + "/" + app.DebugPath)
			if err != nil {
				log.Fatal(err)
			}
			log.Printf("Develop path %s", config.Apps[idx].DebugPath)
		}
		config.Apps[idx].WorkPath = config.Output + "/" + app.Name
		log.Printf("workpath: %s", config.Apps[idx].WorkPath)
		if !filepath.IsAbs(app.SetupTarget) {
			log.Fatal("Invalid setup_target_path")
		}

		for i, ext := range app.Externs {
			if !filepath.IsAbs(ext.Source) {
				config.Apps[idx].Externs[i].Source, err = filepath.Abs(currentPath + "/" + ext.Source)
				if err != nil {
					log.Fatal(err)
				}
			}
		}
	}
}

func createVersionConfig(app App) {
	version := config.Version
	if strings.HasSuffix(version, ".h") {
		txt, err := ioutil.ReadFile(version)
		if err != nil {
			log.Println("read version file failed. ", version)
			return
		}
		lines := strings.Split(string(txt), "\n")
		var major, minor, patch, build, ref string
		for _, l := range lines {
			if !strings.Contains(l, "=") || !strings.Contains(l, ";") {
				continue
			}
			token := strings.Split(l, "=")[1]
			token = strings.Split(token, ";")[0]
			token = strings.Trim(token, " ")
			if strings.Contains(l, "major") {
				major = token
			} else if strings.Contains(l, "minor") {
				minor = token
			} else if strings.Contains(l, "patch") {
				patch = token
			} else if strings.Contains(l, "build") {
				build = strings.Replace(token, `"`, "", -1)
			} else if strings.Contains(l, "ref") {
				ref = strings.Replace(token, `"`, "", -1)
			}
		}
		config.Version = fmt.Sprintf("%s.%s.%s.%s.%s", major, minor, patch, build, ref)
		log.Println("find version: ", config.Version)
	} else {
		_ = ioutil.WriteFile(filepath.Join(app.WorkPath, "version"), []byte(version), os.ModePerm)
		log.Println("create version file: ", string(version))
	}
}

func copyFile(from, to string) {
	from = filepath.FromSlash(from)
	to = filepath.FromSlash(to)
	src, _ := os.Open(from)
	defer src.Close()

	dstdir := filepath.Dir(to)
	dir, err := os.Stat(dstdir)
	if dir == nil || os.IsNotExist(err) {
		_ = os.MkdirAll(dstdir, os.ModePerm)
	}

	dst, _ := os.Create(to)
	if dst == nil {
		log.Printf("copy file from %s to %s failed: %v\n", from, to, err)
		return
	}
	defer dst.Close()

	_, err = io.Copy(dst, src)
	if err != nil {
		log.Printf("copy file from %s to %s failed: %v\n", from, to, err)
	}
}

func copyNewFiles(app App) {
	log.Printf("Clear old work path %s", app.WorkPath)
	_ = os.RemoveAll(app.WorkPath)

	log.Printf("create output dir %s", app.WorkPath)
	err := os.MkdirAll(app.WorkPath, os.ModePerm)
	if err != nil {
		log.Fatal(err)
	}
	log.Println("copy new files from ", app.DebugPath, " to ", app.WorkPath)

	_ = filepath.Walk(app.DebugPath, func(path string, info os.FileInfo, err error) error {
		relativePath := strings.Replace(filepath.ToSlash(path), filepath.ToSlash(app.DebugPath), "", -1)
		dest := filepath.Join(app.WorkPath, relativePath)
		if strings.HasSuffix(path, ".dll") || strings.HasSuffix(path, ".exe") {
			copyFile(path, dest)
		}
		return nil
	})

	if len(app.VcRedist) > 0 {
		vc := "vcredist_x64.exe"
		vcfile, _ := os.Stat(vc)
		if vcfile != nil {
			copyFile(vc, app.WorkPath+"/"+vc)
		} else {
			app.VcRedist = ""
			log.Printf("warning: can not find file %s\n", vc)
		}
	}

	log.Println("copy new files ok")
}

func generateInnoProfile(app App) string {
	var defines, programs, externs /*, programs*/ []string
	defines = append(defines, `#define AppName "`+app.Name+`"`)
	defines = append(defines, `#define AppVersion "`+config.Version+`"`)
	defines = append(defines, `#define AppPublisher "`+config.Publisher+`"`)
	defines = append(defines, `#define AppURL "`+config.Url+`"`)
	defines = append(defines, `#define AppExeName "`+app.ExeName+`"`)
	defines = append(defines, `#define AppSourceDir "`+app.WorkPath+`"`)

	if app.WorkPath != "" {
		flags := "ignoreversion recursesubdirs createallsubdirs"
		text := fmt.Sprintf(`Source: "{#AppSourceDir}/*"; Excludes: "\config"; DestDir: "{app}/"; Flags: %s`, flags)
		programs = append(programs, text)
	}

	//fileInfo, _ := os.Stat(app.WorkPath + "/config")
	//if fileInfo != nil && fileInfo.IsDir() {
	//	flags :=
	//	cfg := fmt.Sprintf(`Source: "{#AppSourceDir}/config/*"; DestDir: "{app}/config/"; Flags: %s`, flags)
	//	programs = append(programs, cfg)
	//}

	for _, e := range app.Externs {
		flags := "ignoreversion recursesubdirs createallsubdirs"
		if !e.Override {
			flags += " onlyifdoesntexist uninsneveruninstall"
		}
		externs = append(externs, `Source: "`+e.Source+`"; DestDir: "`+e.Target+`"; Flags: `+flags)
	}

	profile := innoProfileTemplate
	profile = strings.Replace(profile, "$DEFINES$", strings.Join(defines, "\n"), -1)
	profile = strings.Replace(profile, "$APPID$", app.Id, -1)
	profile = strings.Replace(profile, "$SETUP_TARGET$", app.SetupTarget, -1)
	profile = strings.Replace(profile, "$PROGRAM_FILES$", strings.Join(programs, "\n"), -1)
	profile = strings.Replace(profile, "$EXTERN_FILES$", strings.Join(externs, "\n"), -1)

	if len(app.VcRedist) > 0 {
		run := `Filename: "{app}/vcredist_x64.exe"; Parameters:/q;WorkingDir:{tmp};Flags:skipifdoesntexist;StatusMsg:"Installing Runtime...";Check:NeedInstallVCRuntime`
		code := `
var NeedVcRuntime: Boolean;
 
function NeedInstallVCRuntime(): Boolean;
begin
  Result := NeedVcRuntime;
end;
 
function InitializeSetup(): Boolean;
var version: Cardinal;
begin
  if RegQueryDWordValue(HKLM, 'SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\$(VCREGKEY)$', 'Version', version) = false then begin
    NeedVcRuntime := true;
  end;
  Result := true;
end;
`
		code = strings.Replace(code, "$VCREGKEY$", app.VcRedist, -1)
		profile = strings.Replace(profile, "$RUN$", run, -1)
		profile = strings.Replace(profile, "$CODE$", code, -1)
	} else {
		profile = strings.Replace(profile, "$RUN$", "", -1)
		profile = strings.Replace(profile, "$CODE$", "", -1)
	}

	iss := filepath.Join(config.Output, app.Name+"_"+config.Version+".iss")
	log.Println("create iss file: ", iss)
	if err := ioutil.WriteFile(iss, []byte(profile), os.ModePerm); err != nil {
		log.Fatal("create iss file failed: ", err)
	}
	log.Println("create iss file: ", iss, " ok")
	return iss
}

func generateSetupFile(iss string) {
	log.Println("create setup file from ", iss)
	cmd := exec.Command(config.Compiler, "/O"+config.Output, iss)
	output, err := cmd.CombinedOutput()
	if err != nil {
		log.Println(string(output))
		log.Fatal(err)
	}
	log.Println("create setup file ok")
}

func main() {
	log.Printf("======= version releaser 1.4 build.20191218 =======")

	file, _ := exec.LookPath(os.Args[0])
	abs, _ := filepath.Abs(file)
	currentPath = filepath.Dir(abs)

	cfg := "config.json"
	if len(os.Args) > 1 {
		cfg = os.Args[1]
	}
	loadConfig(cfg)

	var iss []string
	for _, app := range config.Apps {
		copyNewFiles(app)
		createVersionConfig(app)
		iss = append(iss, generateInnoProfile(app))
	}
	for _, i := range iss {
		generateSetupFile(i)
	}
}

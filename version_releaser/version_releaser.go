package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

type Config struct {
	Version       string `json:"version"`
	VersionServer string `json:"version_server"`
	Compiler      string `json:"compiler"`
	Output        string `json:"output"`
	Publisher     string `json:"publisher"`
	Url           string `json:"url"`
	Apps          []App  `json:"apps"`
}

type App struct {
	Id          string       `json:"app_id"`
	Name        string       `json:"app_name"`
	ExeName     string       `json:"app_exe"`
	DebugPath   string       `json:"debug_path"`
	WorkPath    string       `json:"work_path"`
	SetupTarget string       `json:"setup_target_path"`
	Externs     []ExternPath `json:"extern_path"`
}

type ExternPath struct {
	Source string `json:"source"`
	Target string `json:"target"`
}

var innoProfileTemplate = `
; Script generated by the Inno Setup Script Wizard.
; SEE THE DOCUMENTATION FOR DETAILS ON CREATING INNO SETUP SCRIPT FILES!

$DEFINES$

[Setup]
; NOTE: The value of AppId uniquely identifies this application.
; Do not use the same AppId value in installers for other applications.
; (To generate a new GUID, click Tools | Generate GUID inside the IDE.)
AppId=$APPID$
AppName={#AppName}
AppVersion={#AppVersion}
;AppVerName={#AppName} {#AppVersion}
AppPublisher={#AppPublisher}
AppPublisherURL={#AppURL}
AppSupportURL={#AppURL}
AppUpdatesURL={#AppURL}
DefaultDirName=$SETUP_TARGET$
DefaultGroupName={#AppName}
OutputBaseFilename={#AppName}_{#AppVersion}
Compression=lzma
SolidCompression=yes

[Languages]
Name: "english"; MessagesFile: "compiler:Default.isl"

[Tasks]
Name: "desktopicon"; Description: "{cm:CreateDesktopIcon}"; GroupDescription: "{cm:AdditionalIcons}"; Flags: unchecked

[Files]
; Program Files
$PROGRAM_FILES$

; Extern Files
$EXTERN_FILES$

; NOTE: Don't use "Flags: ignoreversion" on any shared system files

; can not replace \ to /
[Icons]
Name: "{group}\{#AppName}"; Filename: "{app}\{#AppExeName}"
Name: "{commondesktop}\{#AppName}"; Filename: "{app}\{#AppExeName}"; Tasks: desktopicon

[Run]
Filename: "{app}/{#AppExeName}"; Description: "{cm:LaunchProgram,{#StringChange(AppName, '&', '&&')}}"; Flags: nowait postinstall skipifsilent
Filename: "{app}/vcredist_x64.exe"; Parameters: /q; WorkingDir: {tmp}; Flags: skipifdoesntexist; StatusMsg: "Installing Microsoft Visual C++ Runtime ..."; Check: NeedInstallVCRuntime

; copy a vcredist_x64.exe to install path first
[Code]
var NeedVcRuntime: Boolean;
 
function NeedInstallVCRuntime(): Boolean;
begin
  Result := NeedVcRuntime;
end;
 
function InitializeSetup(): Boolean;
var version: Cardinal;
begin
  if RegQueryDWordValue(HKLM, 'SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\{0D3E9E15-DE7A-300B-96F1-B4AF12B96488}', 'Version', version) = false then begin
    NeedVcRuntime := true;
  end;
  Result := true;
end;
`

var config = Config{}

func loadConfig(cfg string) {
	text, err := ioutil.ReadFile(cfg)
	if err != nil {
		log.Fatal(err)
	}
	if err := json.Unmarshal(text, &config); err != nil {
		log.Fatal(err)
	}

	config.VersionServer = strings.Trim(config.VersionServer, " ")
	if !strings.HasSuffix(config.VersionServer, "/") {
		config.VersionServer += "/"
	}
}

func createVersionConfig(app App) {
	version := map[string]string{"current_version": config.Version, "remote": config.VersionServer + app.Name}
	output, err := json.Marshal(version)
	if err != nil {
		log.Fatal(err)
	}
	_ = ioutil.WriteFile(filepath.Join(app.WorkPath, "version.json"), output, os.ModePerm)
	log.Println("create version.json. ", string(output))
}

func copyFile(from, to string) {
	from = filepath.FromSlash(from)
	to = filepath.FromSlash(to)
	cmd := exec.Command("xcopy", "/y", "/f", from, to)
	if err := cmd.Run(); err != nil {
		log.Println("copy file failed: ", err, "[xcopy /y /f "+from+" "+to+"]")
	}
}

func copyNewFiles(app App) {
	log.Println("copy new files from ", app.DebugPath, " to ", app.WorkPath)

	_ = filepath.Walk(app.DebugPath, func(path string, info os.FileInfo, err error) error {
		relativePath := strings.Replace(filepath.ToSlash(path), filepath.ToSlash(app.DebugPath), "", -1)
		dest := filepath.Join(app.WorkPath, relativePath)
		if strings.HasSuffix(path, ".dll") || strings.HasSuffix(path, ".exe") {
			copyFile(path, filepath.Dir(dest))
		}
		return nil
	})

	log.Println("copy new files ok")
}

func generateInnoProfile(app App) string {
	var defines, programs, externs /*, programs*/ []string
	defines = append(defines, `#define AppName "`+app.Name+`"`)
	defines = append(defines, `#define AppVersion "`+config.Version+`"`)
	defines = append(defines, `#define AppPublisher "`+config.Publisher+`"`)
	defines = append(defines, `#define AppURL "`+config.Url+`"`)
	defines = append(defines, `#define AppExeName "`+app.ExeName+`"`)
	defines = append(defines, `#define AppSourceDir "`+app.WorkPath+`"`)

	if app.WorkPath != "" {
		flags := "ignoreversion recursesubdirs createallsubdirs"
		text := fmt.Sprintf(`Source: "{#AppSourceDir}/*"; Excludes: "\config"; DestDir: "{app}/"; Flags: %s`, flags)
		programs = append(programs, text)
	}

	fileInfo, _ := os.Stat(app.WorkPath + "/config")
	if fileInfo.IsDir() {
		flags := "ignoreversion recursesubdirs createallsubdirs onlyifdoesntexist uninsneveruninstall"
		cfg := fmt.Sprintf(`Source: "{#AppSourceDir}/config/*"; DestDir: "{app}/config/"; Flags: %s`, flags)
		programs = append(programs, cfg)
	}

	for _, e := range app.Externs {
		externs = append(externs, `Source: "`+e.Source+`"; DestDir: "`+e.Target+`"; Flags: ignoreversion`)
	}

	profile := innoProfileTemplate
	profile = strings.Replace(profile, "$DEFINES$", strings.Join(defines, "\n"), -1)
	profile = strings.Replace(profile, "$APPID$", app.Id, -1)
	profile = strings.Replace(profile, "$SETUP_TARGET$", app.SetupTarget, -1)
	profile = strings.Replace(profile, "$PROGRAM_FILES$", strings.Join(programs, "\n"), -1)
	profile = strings.Replace(profile, "$EXTERN_FILES$", strings.Join(externs, "\n"), -1)

	iss := filepath.Join(config.Output, app.Name+"_"+config.Version+".iss")
	log.Println("create iss file: ", iss)
	if err := ioutil.WriteFile(iss, []byte(profile), os.ModePerm); err != nil {
		log.Fatal(err)
	}
	log.Println("create iss file: ", iss, " ok")
	return iss
}

func generateSetupFile(iss string) {
	log.Println("create setup file from ", iss)
	cmd := exec.Command(config.Compiler, "/O"+config.Output, iss)
	output, err := cmd.CombinedOutput()
	if err != nil {
		log.Println(string(output))
		log.Fatal(err)
	}
	log.Println("create setup file ok")
}

func main() {
	log.Println(os.Args)

	cfg := "config.json"
	if len(os.Args) > 1 {
		cfg = os.Args[1]
	}
	loadConfig(cfg)

	var iss []string
	for _, app := range config.Apps {
		copyNewFiles(app)
		createVersionConfig(app)
		iss = append(iss, generateInnoProfile(app))
	}
	for _, i := range iss {
		generateSetupFile(i)
	}
}

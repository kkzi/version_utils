package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
)

import "embed"

//go:embed iscc
var iscc embed.FS
var isccPath string

type Config struct {
	Version   string `json:"version"`
	Compiler  string `json:"compiler"`
	Publisher string `json:"publisher"`
	Url       string `json:"url"`
	Apps      []App  `json:"apps"`
}

type App struct {
	Id                 string         `json:"app_id"`
	Name               string         `json:"app_name"`
	ExeName            string         `json:"app_exe"`
	BuildPath          string         `json:"build_path"`
	VcRedist           string         `json:"vcredist"`
	Externals          []ExternalPath `json:"external_path"`
	SetupIcon          string         `json:"setup_icon"`
	RegisterExt        string         `json:"registry_ext"`
	RegisterExtName    string         `json:"registry_ext_name"`
	RegisterExtIconIdx int            `json:"registry_ext_icon_idx"`
	WorkPath           string
}

type ExternalPath struct {
	Source   string `json:"source"`
	Target   string `json:"target"`
	Override bool   `json:"override"`
}

var ignores string
var innoProfileTemplate = `
; Script generated by the Inno Setup Script Wizard.
; SEE THE DOCUMENTATION FOR DETAILS ON CREATING INNO SETUP SCRIPT FILES!

$DEFINES$

[Setup]
; NOTE: The value of AppId uniquely identifies this application.
; Do not use the same AppId value in installers for other applications.
; (To generate a new GUID, click Tools | Generate GUID inside the IDE.)
AppId=$APPID$
AppName={#AppName}
AppVersion={#AppVersion}
;AppVerName={#AppName} {#AppVersion}
AppPublisher={#AppPublisher}
AppPublisherURL={#AppURL}
AppSupportURL={#AppURL}
AppUpdatesURL={#AppURL}
DefaultDirName=$SETUP_TARGET$
DefaultGroupName=Atom
OutputBaseFilename={#AppName}_{#AppVersion}
Compression=lzma
SolidCompression=yes
PrivilegesRequired=admin
WizardStyle=modern
SetupIconFile=$SETUP_ICON$


[Languages]
Name: "english"; MessagesFile: "compiler:Default.isl"
Name: "chinesesimplified"; MessagesFile: "compiler:cn.isl"

[Tasks]
Name: "desktopicon"; Description: "{cm:CreateDesktopIcon}"; GroupDescription: "{cm:AdditionalIcons}"

[Files]
; Program Files
$PROGRAM_FILES$

; Extern Files
$EXTERN_FILES$

; NOTE: Don't use "Flags: ignoreversion" on any shared system files

[Registry]
$REGISTRY_BLOCK$

; can not replace \ to /
[Icons]
Name: "{group}\{#AppName}"; Filename: "{app}\{#AppExeName}"
Name: "{group}\{cm:UninstallProgram,{#AppName}}"; Filename: "{uninstallexe}"
Name: "{commondesktop}\{#AppName}"; Filename: "{app}\{#AppExeName}"; Tasks: desktopicon

[Run]
Filename: "{app}\{#AppExeName}"; Description: "{cm:LaunchProgram,{#StringChange(AppName, '&', '&&')}}"; Flags: nowait postinstall skipifsilent
$RUN$

; copy a vcredist_x64.exe to install path first
[Code]
$CODE$

[UninstallDelete]
Type: filesandordirs; Name: "{app}\logs";
Type: filesandordirs; Name: "{app}\Bin\logs";
Type: filesandordirs; Name: "{app}\bin\logs";
`

var workspace string
var configPath string
var config = Config{}

func loadConfig() {
	log.Printf("load config, path=%s\n", configPath)
	text, err := ioutil.ReadFile(configPath)
	if err != nil {
		log.Fatal(err)
	}
	if err := json.Unmarshal(text, &config); err != nil {
		log.Fatal(err)
	}

	for idx, app := range config.Apps {
		if !filepath.IsAbs(app.BuildPath) {
			config.Apps[idx].BuildPath, err = filepath.Abs(app.BuildPath)
			if err != nil {
				log.Fatal(err)
			}
		}
		config.Apps[idx].BuildPath = filepath.ToSlash(config.Apps[idx].BuildPath)
		log.Printf("build path=%s\n", config.Apps[idx].BuildPath)

		config.Apps[idx].WorkPath = filepath.ToSlash(workspace + "/" + app.Name)
		log.Printf("work path=%s\n", config.Apps[idx].WorkPath)

		//if !filepath.IsAbs(app.SetupTarget) {
		//	log.Printf("invalid setup_target_path setup path=%s\n", app.SetupTarget)
		//}

		for i, ext := range app.Externals {
			if !filepath.IsAbs(ext.Source) {
				path, err := filepath.Abs(ext.Source)
				if err != nil {
					log.Fatal(err)
				}
				config.Apps[idx].Externals[i].Source = filepath.ToSlash(path)
			}
		}

		if len(app.ExeName) > 0 {
			config.Apps[idx].ExeName = strings.ReplaceAll(app.ExeName, "/", "\\")
		}
		if len(app.RegisterExt) > 0 && !strings.HasPrefix(app.RegisterExt, ".") {
			config.Apps[idx].RegisterExt = "." + app.RegisterExt
		}
		if len(app.RegisterExtName) > 0 {
			config.Apps[idx].RegisterExtName = strings.ReplaceAll(app.RegisterExtName, " ", "")
		}
		if len(app.SetupIcon) > 0 && !filepath.IsAbs(app.SetupIcon) {
			config.Apps[idx].SetupIcon, err = filepath.Abs(app.SetupIcon)
			if err != nil {
				log.Fatal(err)
			}
		}
	}

	log.Printf("load config ok. path=%s\n", configPath)
}

func loadIgnore() {
	log.Printf("load ignore list\n")
	_, err := os.Stat("ignore.txt")
	if err != nil {
		ignores = ""
		return
	}
	text, err := ioutil.ReadFile("ignore.txt")
	if err != nil {
		//log.Fatal().Err(err).Msg("")
		log.Fatal(err)
	}

	rText := strings.Replace(string(text), "\\", "/", -1)
	rText = strings.Replace(rText, "\r", "", -1) //winϵͳ
	re := regexp.MustCompile(`(\s)+`)
	rText = re.ReplaceAllString(rText, "\n")
	rText = strings.Trim(rText, "\n")

	log.Printf("load ignore list ok, ignore=%s\n", strings.Replace(rText, "\n", ",", -1))
	if rText != "" {
		rText += "\n"
		re = regexp.MustCompile(`(.*)\s`)
		ignores = re.ReplaceAllString(rText, `(${1})|`)
		ignores = ignores[:len(ignores)-1]
		ignores = strings.Replace(ignores, "*", "([^|><?*\":\\/]*\\\\)*([^|><?*\":\\/]*)?", -1)
		ignores = strings.Replace(ignores, ".", "\\.", -1)
	}
}

func extractEmbedFiles(src, dst string) {
	entries, _ := iscc.ReadDir(src)
	for _, entry := range entries {
		srcPath := src + "/" + entry.Name()
		dstPath := dst + "/" + entry.Name()
		if entry.IsDir() {
			extractEmbedFiles(srcPath, dstPath)
		} else {
			copyFile(srcPath, dstPath)
		}
	}
}

func createVersionConfig(app App) {
	version := config.Version
	if strings.HasSuffix(version, ".h") {
		txt, err := ioutil.ReadFile(version)
		if err != nil {
			log.Printf("read version file failed. version=%s\n", version)
			return
		}
		lines := strings.Split(string(txt), "\n")
		var major, minor, patch, build, ref string
		for _, l := range lines {
			if !strings.Contains(l, "=") || !strings.Contains(l, ";") {
				continue
			}
			token := strings.Split(l, "=")[1]
			token = strings.Split(token, ";")[0]
			token = strings.Trim(token, " ")
			if strings.Contains(l, "major") {
				major = token
			} else if strings.Contains(l, "minor") {
				minor = token
			} else if strings.Contains(l, "patch") {
				patch = token
			} else if strings.Contains(l, "build") {
				build = strings.Replace(token, `"`, "", -1)
			} else if strings.Contains(l, "ref") {
				ref = strings.Replace(token, `"`, "", -1)
			}
		}
		config.Version = strings.Join([]string{major, minor, patch, build, ref}, ".")
		if strings.HasSuffix(config.Version, ".") {
			config.Version = config.Version[:len(config.Version)-1]
		}
		for i := 0; i < 3; i++ {
			config.Version = strings.ReplaceAll(config.Version, "..", ".")
		}
		log.Printf("app version=%s\n", config.Version)
	} else {
		_ = ioutil.WriteFile(filepath.Join(app.WorkPath, "version"), []byte(version), os.ModePerm)
		log.Printf("create version file\n")
	}
}

func copyFile(from, to string) {
	stat, err := os.Stat(from)
	if err != nil || stat.IsDir() {
		return
	}
	from = filepath.ToSlash(from)
	to = filepath.ToSlash(to)
	src, _ := os.Open(from)
	defer src.Close()

	dstdir := filepath.Dir(to)
	dir, err := os.Stat(dstdir)
	if dir == nil || os.IsNotExist(err) {
		_ = os.MkdirAll(dstdir, os.ModePerm)
	}

	dst, _ := os.Create(to)
	if dst == nil {
		log.Printf("copy failed. from=%s, to=%s\n", from, to)
		return
	}
	defer dst.Close()

	_, err = io.Copy(dst, src)
	log.Printf("copy from %s, to %s\n", src, dst)
	if err != nil {
		log.Printf("copy failed, %s. from=%s, to=%s\n", err, from, to)
	}
}

func copyNewFiles(app App) {
	log.Printf("remove dir, path=%s\n", app.WorkPath)
	_ = os.RemoveAll(app.WorkPath)

	log.Printf("create dir, path=%s\n", app.WorkPath)
	err := os.MkdirAll(app.WorkPath, os.ModePerm)
	if err != nil {
		log.Fatal(err)
	}
	log.Printf("copy files, from=%s, to=%s\n", app.BuildPath, app.WorkPath)

	re := regexp.MustCompile(ignores)
	_ = filepath.Walk(app.BuildPath, func(path string, info os.FileInfo, err error) error {
		ext := filepath.Ext(path)
		formatPath := strings.Replace(path, "\\", "/", -1)
		if len(ext) > 0 && ignores != "" && re.MatchString(formatPath) {
			return nil
		}
		relativePath := strings.Replace(filepath.ToSlash(path), filepath.ToSlash(app.BuildPath), "", -1)
		dest := filepath.Join(app.WorkPath, relativePath)
		copyFile(path, dest)
		return nil
	})

	if len(app.VcRedist) > 0 {
		vc := "vcredist_x64.exe"
		vcfile, _ := os.Stat(vc)
		if vcfile != nil {
			copyFile(vc, app.WorkPath+"/"+vc)
		} else {
			app.VcRedist = ""
			log.Printf("can not find file, path=%s\n", vc)
		}
	}

	log.Printf("copy files ok\n")
}

func generateDefinesBlock(app App) string {
	var defines []string
	defines = append(defines, `#define AppName "`+app.Name+`"`)
	defines = append(defines, `#define AppVersion "`+config.Version+`"`)
	defines = append(defines, `#define AppPublisher "`+config.Publisher+`"`)
	defines = append(defines, `#define AppURL "`+config.Url+`"`)
	defines = append(defines, `#define AppExeName "`+app.ExeName+`"`)
	defines = append(defines, `#define AppSourceDir "`+app.WorkPath+`"`)
	defines = append(defines, `#define AppAssocExt "`+app.RegisterExt+`"`)
	defines = append(defines, `#define AppAssocName "`+app.RegisterExtName+`"`)
	defines = append(defines, `#define AppAssocKey StringChange(AppAssocName, " ", "") + AppAssocExt`)
	defines = append(defines, `#define AppAssocIconIdx `+strconv.Itoa(app.RegisterExtIconIdx))
	return strings.Join(defines, "\n")
}

func generateProgramsBlock(app App) string {
	var programs []string
	if app.WorkPath != "" {
		flags := "ignoreversion recursesubdirs createallsubdirs"
		text := fmt.Sprintf(`Source: "{#AppSourceDir}/*"; DestDir: "{app}/"; Flags: %s`, flags)
		//text := fmt.Sprintf(`Source: "{#AppSourceDir}/*"; Excludes: "\config"; DestDir: "{app}/"; Flags: %s`, flags)
		programs = append(programs, text)
	}
	return strings.Join(programs, "\n")
}

func generateExternBlock(app App) string {
	var externs []string
	for _, e := range app.Externals {
		flags := "ignoreversion recursesubdirs createallsubdirs"
		if !e.Override {
			flags += " onlyifdoesntexist uninsneveruninstall"
		}
		externs = append(externs, `Source: "`+e.Source+`"; DestDir: "`+e.Target+`"; Flags: `+flags)
	}
	return strings.Join(externs, "\n")
}

func generateRegistryBlock(app App) string {
	if len(app.RegisterExt) > 0 {
		return `
Root: HKA; Subkey: "Software\Classes\{#AppAssocExt}\OpenWithProgids"; ValueType: string; ValueName: "{#AppAssocKey}"; ValueData: ""; Flags: uninsdeletevalue
Root: HKA; Subkey: "Software\Classes\{#AppAssocKey}"; ValueType: string; ValueName: ""; ValueData: "{#AppAssocName}"; Flags: uninsdeletekey
Root: HKA; Subkey: "Software\Classes\{#AppAssocKey}\DefaultIcon"; ValueType: string; ValueName: ""; ValueData: "{app}\{#AppExeName},{#AppAssocIconIdx}"
Root: HKA; Subkey: "Software\Classes\{#AppAssocKey}\shell\open\command"; ValueType: string; ValueName: ""; ValueData: """{app}\{#AppExeName}"" ""%1"""
Root: HKA; Subkey: "Software\Classes\Applications\{#AppExeName}\SupportedTypes"; ValueType: string; ValueName: "${#AppAssocExt}"; ValueData: ""
`
	}
	return ""
}

func generateInnoProfile(app App) string {
	definesBlock := generateDefinesBlock(app)
	programsBlock := generateProgramsBlock(app)
	externsBlock := generateExternBlock(app)
	registryBlock := generateRegistryBlock(app)

	targetPath := "C:/Program Files/Atom/" + app.Name
	profile := innoProfileTemplate
	profile = strings.Replace(profile, "$DEFINES$", definesBlock, -1)
	profile = strings.Replace(profile, "$APPID$", app.Id, -1)
	profile = strings.Replace(profile, "$SETUP_TARGET$", targetPath, -1)
	profile = strings.Replace(profile, "$PROGRAM_FILES$", programsBlock, -1)
	profile = strings.Replace(profile, "$EXTERN_FILES$", externsBlock, -1)
	profile = strings.Replace(profile, "$REGISTRY_BLOCK$", registryBlock, -1)
	profile = strings.Replace(profile, "$SETUP_ICON$", app.SetupIcon, -1)

	if len(app.VcRedist) > 0 {
		run := `Filename: "{app}/vcredist_x64.exe"; Parameters:/q;WorkingDir:{tmp};Flags:skipifdoesntexist;StatusMsg:"Installing Runtime...";Check:NeedInstallVCRuntime`
		code := `
var NeedVcRuntime: Boolean;

function NeedInstallVCRuntime(): Boolean;
begin
  Result := NeedVcRuntime;
end;

function InitializeSetup(): Boolean;
var version: Cardinal;
begin
  if (DirExists ('C:\Program Files\Atom\Monitor')) then
  begin
    DelTree('C:\Program Files\Atom\Monitor', True, True, True);
  end;
  
  if (FileExists (ExpandConstant('{userdesktop}\Monitor.lnk'))) then
  begin
    DelTree(ExpandConstant('{userdesktop}\Monitor.lnk'), True, True, True);
  end;

  if (FileExists ('C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Atom\Monitor.lnk')) then
  begin
    DelTree('C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Atom\Monitor.lnk', True, True, True);
  end;
  if (FileExists ('C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Atom\Uninstall Monitor.lnk')) then
  begin
    DelTree('C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Atom\Uninstall Monitor.lnk', True, True, True);
  end;

  if RegQueryDWordValue(HKLM, 'SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\$(VCREGKEY)$', 'Version', version) = false then begin
    NeedVcRuntime := true;
  end;
  Result := true;
end;
`
		code = strings.Replace(code, "$VCREGKEY$", app.VcRedist, -1)
		profile = strings.Replace(profile, "$RUN$", run, -1)
		profile = strings.Replace(profile, "$CODE$", code, -1)
	} else {
		profile = strings.Replace(profile, "$RUN$", "", -1)
		profile = strings.Replace(profile, "$CODE$", "", -1)
	}

	iss := filepath.Join(workspace, app.Name+"_"+config.Version+".iss")
	iss = filepath.ToSlash(iss)
	log.Printf("create iss file, path=%s\n", iss)
	if err := ioutil.WriteFile(iss, []byte(profile), os.ModePerm); err != nil {
		log.Fatal(err)
	}
	log.Printf("create iss file ok, path=%s\n", iss)
	return iss
}

func generateSetupFile(iss string) {
	log.Printf("create setup file, path=%s\n", iss)
	cmd := exec.Command(config.Compiler, "/O"+workspace, iss)
	output, err := cmd.CombinedOutput()
	if err != nil {
		log.Printf("%s\n", output)
		log.Fatal(err)
	}
	log.Printf("create setup file ok\n")
}

func init() {
	flag.StringVar(&workspace, "w", "./workspace", "workspace path")
	flag.StringVar(&configPath, "c", "./config.json", "config file path")
}

func main() {
	log.SetFlags(log.Lmicroseconds)
	fmt.Println("======= version releaser 2.7 build.20210416 =======")
	flag.Parse()

	if !filepath.IsAbs(workspace) {
		workspace, _ = filepath.Abs(workspace)
	}
	workspace = filepath.ToSlash(workspace)

	log.Printf("workspace=%s, config paht=%s\n", workspace, configPath)
	loadConfig()
	loadIgnore()

	if len(config.Compiler) == 0 {
		isccPath, _ = ioutil.TempDir("", "iscc")
		config.Compiler = isccPath + "\\iscc.exe"
		log.Printf("use iscc path %s\n", isccPath)
		extractEmbedFiles("iscc", isccPath)
	}

	var iss []string
	for _, app := range config.Apps {
		copyNewFiles(app)
		createVersionConfig(app)
		iss = append(iss, generateInnoProfile(app))
	}
	for _, i := range iss {
		generateSetupFile(i)
	}
}

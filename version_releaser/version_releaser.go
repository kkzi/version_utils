package main

import (
	"encoding/json"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

type Config struct {
	Version       string `json:"version"`
	VersionServer string `json:"version_server"`
	Compiler      string `json:"compiler"`
	Output        string `json:"output"`
	Publisher     string `json:"publisher"`
	Url           string `json:"url"`
	Apps          []App  `json:"apps"`
}

type App struct {
	Id          string       `json:"app_id"`
	Name        string       `json:"app_name"`
	ExeName     string       `json:"app_exe"`
	DebugPath   string       `json:"debug_path"`
	WorkPath    string       `json:"work_path"`
	BasePath    string       `json:"base_path"`
	ConfigPath  string       `json:"config_path"`
	SetupTarget string       `json:"setup_target_path"`
	Externs     []ExternPath `json:"extern_path"`
}

type ExternPath struct {
	Source string `json:"source"`
	Target string `json:"target"`
}

var innoProfileTemplate = `
; Script generated by the Inno Setup Script Wizard.
; SEE THE DOCUMENTATION FOR DETAILS ON CREATING INNO SETUP SCRIPT FILES!

$DEFINES$

[Setup]
; NOTE: The value of AppId uniquely identifies this application.
; Do not use the same AppId value in installers for other applications.
; (To generate a new GUID, click Tools | Generate GUID inside the IDE.)
AppId=$APPID$
AppName={#MyAppName}
AppVersion={#MyAppVersion}
;AppVerName={#MyAppName} {#MyAppVersion}
AppPublisher={#MyAppPublisher}
AppPublisherURL={#MyAppURL}
AppSupportURL={#MyAppURL}
AppUpdatesURL={#MyAppURL}
DefaultDirName=$SETUP_TARGET$
DefaultGroupName={#MyAppName}
OutputBaseFilename={#MyAppName}_{#MyAppVersion}
Compression=lzma
SolidCompression=yes

[Languages]
Name: "english"; MessagesFile: "compiler:Default.isl"

[Tasks]
Name: "desktopicon"; Description: "{cm:CreateDesktopIcon}"; GroupDescription: "{cm:AdditionalIcons}"; Flags: unchecked

[Files]
; Base Files
$BASE_FILES$

; Config Files
$CONFIG_FILES$

; Extern Files
$EXTERN_FILES$

; Program Files
$PROGRAM_FILES$

; NOTE: Don't use "Flags: ignoreversion" on any shared system files

[Icons]
Name: "{group}\{#MyAppName}"; Filename: "{app}\{#MyAppExeName}"
Name: "{commondesktop}\{#MyAppName}"; Filename: "{app}\{#MyAppExeName}"; Tasks: desktopicon

[Run]
Filename: "{app}\{#MyAppExeName}"; Description: "{cm:LaunchProgram,{#StringChange(MyAppName, '&', '&&')}}"; Flags: nowait postinstall skipifsilent
`

var config = Config{}

func loadConfig() {
	text, err := ioutil.ReadFile("./config.json")
	if err != nil {
		log.Fatal(err)
	}
	if err := json.Unmarshal(text, &config); err != nil {
		log.Fatal(err)
	}

	config.VersionServer = strings.Trim(config.VersionServer, " ")
	if !strings.HasSuffix(config.VersionServer, "/") {
		config.VersionServer += "/"
	}
}

func createVersionConfig(app App) {
	version := map[string]string{"current_version": config.Version, "remote": config.VersionServer + app.Name}
	output, err := json.Marshal(version)
	if err != nil {
		log.Fatal(err)
	}
	ioutil.WriteFile(filepath.Join(app.WorkPath, "version.json"), output, os.ModePerm)
	log.Println("create version.json. ", string(output))
}

func copyFile(from, to string) {
	from = filepath.FromSlash(from)
	to = filepath.FromSlash(to)
	cmd := exec.Command("xcopy", "/y", "/f", from, to)
	if err := cmd.Run(); err != nil {
		log.Println("copy file failed: ", err, "[xcopy /y /f "+from+" "+to+"]")
	}
}

func copyNewFiles(app App) {
	log.Println("copy new files from ", app.DebugPath, " to ", app.WorkPath)

	filepath.Walk(app.DebugPath, func(path string, info os.FileInfo, err error) error {
		relativePath := strings.Replace(filepath.ToSlash(path), filepath.ToSlash(app.DebugPath), "", -1)
		dest := filepath.Join(app.WorkPath, relativePath)
		if strings.HasSuffix(path, ".dll") || strings.HasSuffix(path, ".exe") {
			copyFile(path, filepath.Dir(dest))
		}
		return nil
	})

	log.Println("copy new files ok")
}

func generateInnoProfile(app App) string {
	isDemo := len(os.Args) > 1 && os.Args[1] == "demo"
	if isDemo {
		app.Name = app.Name + "Demo"
	}

	var defines, configs, bases, externs /*, programs*/ []string
	defines = append(defines, `#define MyAppName "`+app.Name+`"`)
	defines = append(defines, `#define MyAppVersion "`+config.Version+`"`)
	defines = append(defines, `#define MyAppPublisher "`+config.Publisher+`"`)
	defines = append(defines, `#define MyAppURL "`+config.Url+`"`)
	defines = append(defines, `#define MyAppExeName "`+app.ExeName+`"`)

	if app.ConfigPath != "" && isDemo {
		configs = append(configs, generateDirText(app.ConfigPath))
	}
	if app.BasePath != "" {
		bases = append(bases, generateDirText(app.BasePath))
	}

	for _, e := range app.Externs {
		externs = append(externs, `Source: "`+e.Source+`"; DestDir: "`+e.Target+`"; Flags: ignoreversion`)
	}

	//files, _ := ioutil.ReadDir(app.WorkPath)
	//temps := []string{}
	//for _, p := range files {
	//	path, _ := filepath.Abs(filepath.Join(app.WorkPath, p.Name()))
	//	if p.IsDir() {
	//		if strings.ToLower(p.Name()) != "config" {
	//			programs = append(programs, generateDirText(path))
	//		}
	//	} else {
	//		temps = append(temps, path)
	//	}
	//}
	//for _, p := range temps {
	//	programs = append(programs, generateFileText(p))
	//}

	programsDir := `Source: "` + app.WorkPath + `/*"; DestDir: "{app}/"; Flags: ignoreversion recursesubdirs createallsubdirs`


	profile := innoProfileTemplate
	profile = strings.Replace(profile, "$DEFINES$", strings.Join(defines, "\n"), -1)
	profile = strings.Replace(profile, "$APPID$", app.Id, -1)
	profile = strings.Replace(profile, "$SETUP_TARGET$", app.SetupTarget, -1)
	profile = strings.Replace(profile, "$BASE_FILES$", strings.Join(bases, "\n"), -1)
	profile = strings.Replace(profile, "$EXTERN_FILES$", strings.Join(externs, "\n"), -1)
	profile = strings.Replace(profile, "$CONFIG_FILES$", strings.Join(configs, "\n"), -1)
	profile = strings.Replace(profile, "$PROGRAM_FILES$", programsDir, -1)


	iss := filepath.Join(config.Output, app.Name+"_"+config.Version+".iss")
	log.Println("create iss file: ", iss)
	if err := ioutil.WriteFile(iss, []byte(profile), os.ModePerm); err != nil {
		log.Fatal(err)
	}
	log.Println("create iss file: ", iss, " ok")
	return iss
}

func generateSetupFile(iss string) {
	log.Println("create setup file from ", iss)
	cmd := exec.Command(config.Compiler, "/O"+config.Output, iss)
	output, err := cmd.CombinedOutput()
	if err != nil {
		log.Println(string(output))
		log.Fatal(err)
	}
	log.Println("create setup file ok")
}

func generateDirText(src string) string {
	flags := `Flags: ignoreversion recursesubdirs createallsubdirs`
	dir := filepath.Base(src)
	return `Source: "` + src + `/*"; DestDir: "{app}/` + dir + `"; ` + flags
}

func generateFileText(src string) string {
	flags := `Flags: ignoreversion`
	return `Source: "` + src + `"; DestDir: "{app}"; ` + flags
}

func main() {
	log.Println(os.Args)
	loadConfig()

	var iss []string
	for _, app := range config.Apps {
		copyNewFiles(app)
		createVersionConfig(app)
		iss = append(iss, generateInnoProfile(app))
	}
	for _, i := range iss {
		generateSetupFile(i)
	}
}

